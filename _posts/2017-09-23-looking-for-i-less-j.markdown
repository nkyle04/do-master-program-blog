---
layout: post
title: looking for i less j
date: 2017-07-30
categories: program
---
## About this topic
这里计划说明几个问题，都是跟查找满足i < j && A[i] < A[j]相关的问题。因为他们有相通之处，因此可以放在一起类比。
## Problem description
 
# 问题一
给定一个无序的数组array，长度为n。要求满足条件：索引i < j，同时满足A[i] < A[j]。求满足这两个条件的[i,j]中，使得A[j] - A[i]最大的索引。
# 问题二
还是上面描述的无序数组array，长度为n。要求满足上述i < j && A[i] < A[j]。求满足这两个条件的[i,j]中，使得j - i最大的索引。
# 问题三
给定一个无序数组array，长度为n。求是否存在数组索引i，j，k。满足i < j < k && A[i] < A[j] < A[k]？即满足“小、中、大”的顺序
# 问题四
给定一个无序数组array，长度为n。求是否存在数组索引i，j，k。满足i < j < k && A[i] < A[k] < A[j]？即满足“小、大、中”的顺序

## 解法
# 问题一，求A[j] - A[i]最大
这个问题可以在O(n)时间复杂度内解决，对于空间复杂度，比较好的是O(1)
代码如下。基本思路就是遍历一次数组array，在遍历过程中保存一个当前见到的最小值和当前见到的最大值，求max_diff = std::max(max_diff, max - min)。如果更新了max_diff，则保存新的索引。
# 问题二，求j - i最大
这个问题跟问题一非常像，只不过转了个方向，因此我们可以把方向再转回来。对array生成一个rank数组，然后对rank数组按问题一的方式求R[j] - R[i]最大
# 问题三，求满足“小，中，大”
这也是一个O(n)复杂度就能解决的问题，解法跟问题一类似，这里也是存当前见到的max和min。先顺序开始找min，当找到大于min的值时，保存到max，之后继续遍历更新min和max，当找到大于max的就可以完成任务了。因为一旦max有值，那么说明存在一个min<max，之后我们只要找到大于max的值就可以了。
# 问题四，求满足“小，大，中”
这个问题就比较复杂了，需要n+2nlogn的复杂度。
1. 首先需要创建一个辅助数组Min，对每个Min[i]保存数组Array中索引小于i的最小值。也就是一个最小值数组
2. 然后从后往前遍历数组Array，对每个元素，先检查A[i] > Min[i]，然后从一个辅助二叉搜索树中查找小于A[i]的最大值，这个操作需要至少logn的复杂度。如果不满足条件，则把当前元素插入到二叉搜索树中，插入操作消耗logn的复杂度。所以这一步的复杂度是n*2logn。
3. 这里总共用了两块辅助空间，一个是Min数组，另一个是辅助二叉搜索树

重点在第二步，通过从后往前遍历的方式，并且在遍历过程中插入二叉搜索树，这样从搜索树中查询到的就是满足索引大于i并且A[i] > A[j]的值。因为还要求这个值是比min大，所以是从二叉搜索树中查找满足条件的最大值。


